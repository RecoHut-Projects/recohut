# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/models/models.itempop.ipynb (unless otherwise specified).

__all__ = ['ItemPop']

# Cell
import pandas as pd
from itertools import islice, cycle

# Cell
class ItemPop():
    """
    Makes recommendations based on popular items
    """

    def __init__(self, max_K=10, days=30, item_column='item_id', user_column='user_id', dt_column='date', with_filter=False):
        self.max_K = max_K if not with_filter else 300
        self.days = days
        self.item_column = item_column
        self.user_column = user_column
        self.dt_column = dt_column
        self.recommendations = []

    def fit(self, df, ):
        min_date = df[self.dt_column].max().normalize() - pd.DateOffset(days=self.days)
        self.recommendations = df.loc[df[self.dt_column] > min_date,
                                      self.item_column].value_counts().head(self.max_K).index.values

    def recommend(self, users=None, N=10):
        recs = self.recommendations[:N]
        if users is None:
            return recs
        else:
            return list(islice(cycle([recs]), len(users)))

    def recommend_with_filter(self, train, user_ids, top_K=10):
        user_ids = pd.Series(user_ids)
        _users = user_ids[user_ids.isin(train[self.user_column])]
        new_users = user_ids[~user_ids.isin(_users)]
        full_recs = self.recommendations
        topk_recs = full_recs[:top_K]
        new_recs = pd.DataFrame({self.user_column: new_users})
        new_recs[self.item_column] = list(islice(cycle([topk_recs]), len(new_users)))
        _recs = pd.DataFrame({self.user_column: _users})
        _recs[self.item_column] = 0
        known_items = train.groupby(self.user_column)[self.item_column].apply(list).to_dict()
        _recs['additional_N'] = _recs[self.user_column].apply(
            lambda user_id: len(known_items[user_id]) if user_id in known_items else 0)
        _recs['total_N'] = _recs['additional_N'].apply(
            lambda add_N: add_N + top_K if add_N + top_K < len(full_recs) else len(full_recs))
        _recs['total_recs'] = _recs['total_N'].apply(
            lambda total_N: full_recs[:total_N])
        filter_func = lambda row: [item for item in row['total_recs']
                                   if item not in known_items[row[self.user_column]]][:top_K]
        _recs[self.item_column] = _recs.loc[:, ['total_recs', self.user_column]].apply(
            filter_func, axis=1)
        _recs = _recs[[self.user_column, self.item_column]]
        return pd.concat([new_recs, _recs], axis=0)